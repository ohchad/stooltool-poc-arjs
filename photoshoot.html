<html>

<head>
    <link rel="stylesheet" href="./scripts/material.design.lite.css">
    <link rel="stylesheet" href="./scripts/main.css">

    <script src='./scripts/main.js'></script>
    <script src="./scripts/aframe-master.min.js"></script>
    <script src="./scripts/aframe-ar-nft.js"></script>
    <script src="./scripts/webcam-easy.min.js"></script>
    <script src="./scripts/jquery-3.6.0.min.js"></script>
    <script defer src="./scripts/material.design.lite.js"></script>
    <script defer src='./scripts/tone.js'></script>

</head>


<body style="margin : 0px; overflow: hidden;">

    <div class="controls">
        <h2>Welcome</h2>
        Please enable the camera and your speaker and prepare your diaper to be photographed with the stool tool marker
        in the upper right hand corner of the frame.

        <button id="start"
            class="mdl-button mdl-js-button mdl-button--raised mdl-js-ripple-effect mdl-button--accent send">
            Start
        </button>

    </div>

    <div class='gallery'></div>
    <div class='centered'><img class='crosshairs' src='./assets/crosshairs.red.png' /></div>
    <div class="upper right marker status">
        <div class=" lost">
            please ensure the marker<br> is in this frame
        </div>
        <div class=" found">
            please ensure the marker<br> is in the upper right corner
        </div>
        <div class=" correct">
            Good. Hold steady.
        </div>
    </div>
    <div class='lower right msg'></div>



    <a-scene vr-mode-ui="enabled: false;" renderer="logarithmicDepthBuffer: true;" embedded
        arjs="trackingMethod: best; sourceType: webcam; debugUIEnabled: false; detectionMode: mono_and_matrix; matrixCodeType: 3x3;">
        <a-entity camera></a-entity>

        <!-- create a new marker https://jeromeetienne.github.io/AR.js/three.js/examples/marker-training/examples/generator.html -->
        <a-marker preset='custom' type='pattern' url='./assets/stool.tools.marker.patt' />

    </a-scene>


</body>
<script>

    jQuery(function ($) {

        const config = {
            marker: {
                sample: 175,
            },

            proctor: {
                pause: {
                    overlap: 5000,
                    default: 10_000,
                    upright: 20_000
                },
            },

            perspectives: ['front', 'above', 'back', 'left', 'right'],

            targets: {
                tolerance: 0.9,
                front: { _x: 0.7, _y: 0, _z: 0, },
                above: { _x: 1.6, _y: 0, _z: 0 }, // above is +0.9 rads from front and back is another +0.9 rads
                back: { _x: 2.5, _y: 0, _z: 0, },
                left: { _x: 1.6, _y: 0, _z: 0.9, }, // left and right are 1.8 rads apart
                right: { _x: 1.6, _y: 0, _z: -0.9, },
            },

            /*
                [].concat(... '12345'.split('').map( num => 'CDEFGAB'.split('').map(note=> note + num)))
                ["C1", "D1", "E1", "F1", "G1", "A1", "B1", "C2", "D2", "E2", "F2", "G2", "A2", "B2", "C3", "D3", "E3", "F3", "G3", "A3", "B3", "C4", "D4", "E4", "F4", "G4", "A4", "B4", "C5", "D5", "E5", "F5", "G5", "A5", "B5"]
            */
            beep: {
                notes: [].concat(... '12345'.split('').map(num => 'CDEFGAB'.split('').map(note => note + num))), // returns [C1,C2,C3 ... G5,A5,B5]
                seconds: 1,
            },


        }

        class Speaker {
            constructor() {
                this.oldSound = {}
                this.Tone = new Tone.Volume(-20).toDestination();
            }

            pause() {
                // TODO this.Tone.triggerRelase(config.notes)  // release all notes
                return this
            }

            beep(data) {
                data = data || {}
                if (this.oldSound.note === data.note) return
                const synth = new Tone.Synth().connect(this.Tone)
                synth.triggerAttackRelease(data.note || "C1", data.seconds || "8n");
                return this

            }

            pulse(diff, _seconds) {
                const { notes, seconds } = config.beep
                this.beep({
                    note: notes[Math.floor(diff * notes.length)],
                    seconds: _seconds || seconds || 1,
                    //volume: -20 * (1 - diff),
                    //interval: (1 - diff) * 1000
                })
            }


            // Note:  Pause will not interrupt playing mp3s.  They're always allowed to complete
            play(name) {
                if (name === 'done' && this.oldSound['old'] !== 'done') {
                    this.oldSound.player.stop()
                }

                const { pause } = config.proctor

                const now = Date.now()
                if (now - this.oldSound['old'] < pause.overlap) return  // don't overlap messages
                if (now - this.oldSound[name] < (pause[name] || pause.default)) return // don't repeat the same message more than once every 10 seconds
                this.oldSound['old'] = this.oldSound[name] = now
                const player = new Tone.Player(`./assets/${name}.mp3`).toDestination()
                Tone.loaded().then(() => {
                    player.start();
                    this.oldSound.player = player
                });
                return this
            }
        }



        theSpeaker = new Speaker()

        // lock landscape orientation
        //screen.orientation.lock('landscape')
        //ScreenOrientation.lock('welcome')


        /*

            Position is used for maintaining a constant distance and to ensure both the marker and the stool are within the frame
            We should ensure the marker is in the upper right quadrant of the frame.  In this way, the stool is mostly within the left quadrant and should always be within the frame.  We cannot guarantee it will be entirely in the frame however in all 5 perspectives.
            Rotation values are in radians and are independent of distance
            Left/Right rotations occur in only z and should change by 1 radian
            Front/Back rotations occur in only x and should change by 1 radian
            Therefore, y axis should not change much,  less than 0.5 radian

        */

        const zeros = { x: 0, y: 0, z: 0 }
        const tolerance = 1.2 // values should be within 20%

        const photos = {
            above: { position: { ...zeros }, rotation: { ...zeros }, img: null },
            left: { position: { ...zeros }, rotation: { ...zeros }, img: null },
            right: { position: { ...zeros }, rotation: { ...zeros }, img: null },
            front: { position: { ...zeros }, rotation: { ...zeros }, img: null },
            back: { position: { ...zeros }, rotation: { ...zeros }, img: null },
        }



        function sameSign(a, b) {
            return a === 0 || b === 0 || (a < 0 && b < 0) || (a > 0 && b > 0)
        }

        function sameQuad(target, marker) {
            target = { ...{ _x: 0, _y: 0, _z: 0 }, ...target }
            marker = { ...{ _x: 0, _y: 0, _z: 0 }, ...marker }

            return sameSign(target._x, marker._x)
                && sameSign(target._y, marker._y)
                && sameSign(target._z, marker._z)
        }

        function maxDiff(a, b) {
            let max = 0

            function compareMax(alpha, beta) {
                alpha = alpha < 0 ? -alpha : alpha
                beta = beta < 0 ? -beta : beta
                let ratio = Math.abs(alpha < beta ? alpha / beta : beta / alpha)
                if (ratio < 1 && max < ratio) max = ratio
            }

            compareMax(a.x, b.x)
            compareMax(a.y, b.y)
            compareMax(a.z, b.z)
            compareMax(a._x, b._x)
            compareMax(a._y, b._y)
            compareMax(a._z, b._z)

            return max
        }



        const $markerStatus = $('.marker.status')
        const $crosshairs = $('img.crosshairs')


        // a singleton to improve readability
        const ensure = { marker: null }
        ensure.upperRightQuadrant = (marker) => {
            // Ensure the position of the marker has positive values in both x and y
            const my = (marker && marker.object3D) || ensure.marker
            const { x, y } = my.position
            const good = x > 0 && y > 0
            if (good) {
                $markerStatus.addClass('correct').removeClass('lost found')
                $crosshairs.attr('src', './assets/crosshairs.green.png')
            }
            return good
        }



        // mirror the video, once permission granted and rendered
        // const timer = setInterval(() => {
        //     const vid = document.querySelector('video#arjs-video')
        //     if (vid) {
        //         vid.style.transform = 'scale(-1,1)'
        //         clearInterval(timer)
        //     }
        // }, 500)

        AFRAME.registerComponent('markerhandler', {
            init: function () {
                // this is required, but only to ensure markerFound events are thrown
            }
        });






        function load() {
            const camera = document.querySelector('[camera]');
            const marker = document.querySelector('a-marker');
            let rotation = { ...marker.object3D.rotation }
            let position = { ...marker.object3D.position }
            let distance = camera.object3D.position.distanceTo(position)
            let old, done, timer
            let i = 0
            const $msg = $('.msg')
            const gallery = document.querySelector('div.gallery')

            marker.addEventListener('markerFound', () => {
                if (done) return
                if (timer) return
                timer = setInterval(() => {
                    marker.dispatchEvent(new Event('markerCheck'))
                }, config.marker.sample || 200);
                $markerStatus.addClass('found').removeClass('lost correct')
                $crosshairs.attr('src', './assets/crosshairs.yellow.png')
            })
            marker.addEventListener('markerLost', () => {
                if (done) return
                clearInterval(timer)
                timer = false
                theSpeaker.play('upright')
                $markerStatus.addClass('lost').removeClass('found correct')
                $crosshairs.attr('src', './assets/crosshairs.red.png')
            })


            // capture distance:0, position and rotation
            marker.addEventListener('markerCheck', () => {
                if (done) return
                rotation = { ...marker.object3D.rotation }
                position = { ...marker.object3D.position }
                distance = camera.object3D.position.distanceTo(position)

                //console.log({ distance, rotation, position })
                ensure.marker = { ...marker.object3D }

                /*
                front: { _x: 0.7, _y: 0, _z: 0, },
                above: { _x: 1.6, _y: 0, _z: 0 }, // above is +0.9 rads from front and back is another +0.9 rads
                back: { _x: 2.5, _y: 0, _z: 0, },
                left: { _x: 1.6, _y: 0, _z: 0.9, }, // left and right are 1.8 rads apart
                right: { _x: 1.6, _y: 0, _z: -0.9, },
                */

                if (!ensure.upperRightQuadrant()) {
                    theSpeaker.pause()
                    theSpeaker.play('upright')
                    return
                }

                const name = config.perspectives.find(name => !photos[name].img)

                if (name && !photos[name].img) {
                    console.log('looking ' + name)
                    theSpeaker.play(name)

                    const target = config.targets[name]
                    const tolerance = config.targets.tolerance

                    function pErr(a, b, digits) {
                        const factor = Math.pow(10, digits || config.digits || 2)
                        return Math.floor((Math.abs(a - b) / Math.max(Math.abs(a), Math.abs(b))) * factor) / factor
                    }

                    const delta = {
                        roll: pErr(target._z, rotation._z),
                        pitch: pErr(target._x, rotation._x),
                        yaw: pErr(target._y, rotation._y),
                    }

                    $msg.html(`roll: ${delta.roll} pitch: ${delta.pitch} yaw: ${delta.yaw}`)

                    const diff = maxDiff(target, rotation)
                    theSpeaker.pulse(diff)

                    if (!sameQuad(target, rotation)) return

                    if (diff >= tolerance) {
                        photos[name] = { position, rotation, img: snapPhoto() }
                        theSpeaker.play('good')
                        return
                    }
                } else {
                    if (done) return
                    done = true

                    $('.crosshairs,.status,.msg').fadeOut()
                    theSpeaker.pause();

                    setTimeout(() => {
                        theSpeaker.play('done')
                        console.log('done')

                        $('.msg').html('Thank you.  Refresh the page to repeat.').slideDown()

                        setTimeout(() => {
                            torch(false)
                        }, 1000)

                    }, 3000)

                    return

                }

            })
        }

        $('button#start').click(function () {
            $('.controls').slideUp()
            theSpeaker.play('welcome') // tutorial plays for 10 seconds
            setTimeout(load, 5_000)
        })

    })

</script>

</html>